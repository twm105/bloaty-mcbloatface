# Security Architecture & Developer Guide

This document describes the security architecture of Bloaty McBloatface and what developers need to know when making changes. It covers principles, patterns, and contributor guidance.

Operational details (infrastructure specifics, known gaps, incident history) are in `SECURITY_INTERNAL.md`, which is not committed to the repository. If you need access, ask a project maintainer.

For infrastructure/deployment security, see [DEVOPS.md](DEVOPS.md).

## Security Overview

```
Internet
  │
  ▼
nginx (TLS termination, security headers, file extension checks)
  │
  ▼
FastAPI (CSRF origin validation, auth middleware, input validation)
  │
  ├──► PostgreSQL (ORM-only access, parameterized queries)
  ├──► Redis (session cache, internal only)
  └──► Anthropic API (outbound only, schema-validated responses)
```

All external traffic enters through nginx, which handles TLS and adds security headers. FastAPI enforces CSRF protection and authentication. The database and Redis are only accessible within the Docker network. The Anthropic API is outbound-only with all responses validated through Pydantic schemas before rendering.

---

## Authentication & Authorization

### Session-Based Auth

Authentication uses bcrypt password hashing and database-stored sessions with secure random tokens.

| Setting | Value | File |
|---------|-------|------|
| Password hashing | bcrypt | `app/services/auth/local_provider.py:27-29` |
| Session token | `secrets.token_urlsafe(32)` | `app/services/auth/local_provider.py:38-39` |
| Session storage | PostgreSQL `sessions` table | `app/models/session.py` |
| Session expiry | 7 days (`SESSION_MAX_AGE=604800`) | `app/config.py:32` |
| Cookie: HttpOnly | Yes | `app/api/auth.py:77` |
| Cookie: SameSite | `lax` | `app/api/auth.py:78` |
| Cookie: Secure | Configurable, `true` in production | `app/config.py:33` |

### Invite-Only Registration

New users can only register with a valid invite token. Invites are:
- Generated by admins only (`require_admin` dependency)
- Single-use (marked `used_at` on registration)
- Time-limited (7-day expiry)
- Created with `secrets.token_urlsafe(32)`

Key file: `app/api/auth.py:100-210`

### Auth Dependency Patterns

Use these FastAPI dependencies to protect routes:

```python
from app.services.auth.dependencies import (
    get_current_user,      # Raises 401 — use for API endpoints
    get_optional_user,     # Returns None if not logged in — use for mixed pages
    require_admin,         # Raises 403 if not admin — use for admin-only APIs
    require_auth_page,     # Redirects to /auth/login — use for HTML pages
    require_admin_page,    # Redirects + admin check — use for admin HTML pages
)

# API endpoint example
@router.delete("/meals/{meal_id}")
async def delete_meal(meal_id: int, user: User = Depends(get_current_user)):
    ...

# HTML page example
@router.get("/meals/history")
async def meal_history(request: Request, user: User = Depends(require_auth_page)):
    ...
```

Key file: `app/services/auth/dependencies.py`

### Ownership Verification

Every data query **must** filter by `user_id` to prevent cross-user data access:

```python
# Correct
meal = db.query(Meal).filter(Meal.id == meal_id, Meal.user_id == user.id).first()

# Wrong — allows accessing any user's data
meal = db.query(Meal).filter(Meal.id == meal_id).first()
```

This is tested in `tests/security/test_auth_security.py:TestAccessControl`.

---

## CSRF Protection

### Implementation

The `CSRFOriginMiddleware` in `app/main.py:23-90` validates Origin/Referer headers on all state-changing requests:

1. **Safe methods** (GET, HEAD, OPTIONS) are always allowed
2. **Health endpoints** (`/health`, `/nginx-health`) are exempt
3. **POST/PUT/PATCH/DELETE** must include a matching `Origin` or `Referer` header
4. If neither header is present, the request is rejected with 403

### Design Decision

We use Origin/Referer validation rather than CSRF tokens. This is sufficient because:
- The app is same-origin only (no cross-origin API consumers)
- htmx sends the Origin header automatically on all requests
- Modern browsers reliably include Origin on same-origin POST requests

### What Developers Need to Know

Nothing special. When adding new POST/PUT/PATCH/DELETE endpoints, CSRF protection applies automatically. htmx sends the Origin header, and standard HTML forms include the Referer. No tokens to manage.

Tests: `tests/security/test_htmx_security.py:TestCSRFProtection`

---

## Input Validation & Injection Prevention

### SQL Injection

All database access uses SQLAlchemy ORM with parameterized queries. There is **no raw SQL** anywhere in the codebase.

```python
# How we query (safe — SQLAlchemy parameterizes automatically)
user = db.query(User).filter(User.email == email.lower()).first()

# Never do this
db.execute(f"SELECT * FROM users WHERE email = '{email}'")  # SQL injection!
```

Tests: `tests/security/test_input_validation.py:TestSQLInjection`

### XSS (Cross-Site Scripting)

**Jinja2 autoescaping** is enabled by default. All template variables are HTML-escaped unless explicitly marked `|safe`.

Rules:
- Never use `|safe` on user-provided data
- Pass data to Alpine.js via `<script>` tags with `|tojson`, not inline attributes
- htmx partial responses are also autoescaped since they use the same Jinja2 templates

```html
<!-- Safe: Jinja2 autoescapes -->
<span>{{ meal.name }}</span>

<!-- Safe: tojson for Alpine.js data -->
<script>const data = {{ ingredients|tojson }};</script>

<!-- DANGEROUS: never do this with user data -->
<span>{{ user_input|safe }}</span>
```

Tests: `tests/security/test_input_validation.py:TestXSSPrevention`, `tests/security/test_htmx_security.py:TestPartialResponseEscaping`

### File Uploads

File upload validation in `app/services/file_service.py`:

| Check | Implementation |
|-------|---------------|
| Content-type whitelist | `image/jpeg`, `image/png`, `image/webp` only |
| Server-generated filename | `{timestamp}_{uuid}.{ext}` — user filename is discarded |
| Size limit | 10MB (enforced by nginx `client_max_body_size`) |
| nginx extension check | Only `.jpg`, `.jpeg`, `.png`, `.gif`, `.webp` served from `/uploads/` |
| Image optimization | PIL/Pillow processes and re-saves the image |

The server-generated filename prevents path traversal and command injection via filenames.

Tests: `tests/security/test_input_validation.py:TestPathTraversal`, `TestCommandInjection`

### Path Traversal

- Uploads are served via FastAPI's `StaticFiles` mount, which resolves paths safely
- nginx restricts `/uploads/` to image extensions only, returning 403 for anything else
- No user-controlled path resolution exists in the codebase

---

## Security Headers

Production nginx adds the following headers (configured in `nginx/conf.d/ssl.conf.prod`):

| Header | Value | Purpose |
|--------|-------|---------|
| `X-Frame-Options` | `SAMEORIGIN` | Prevents clickjacking |
| `X-Content-Type-Options` | `nosniff` | Prevents MIME-type sniffing |
| `X-XSS-Protection` | `1; mode=block` | Legacy XSS filter (older browsers) |
| `Referrer-Policy` | `strict-origin-when-cross-origin` | Controls referrer leakage |

---

## Subresource Integrity (SRI)

All CDN-loaded scripts and stylesheets in `app/templates/base.html` are pinned to exact versions with `integrity` hashes and `crossorigin="anonymous"`:

```html
<script src="https://unpkg.com/htmx.org@1.9.10"
        integrity="sha384-D1Kt99CQMDuVetoL1lrYwg5t+9QdHe7NLX/SoJYkXDFfX37iInKRy5xLSi8nO7UC"
        crossorigin="anonymous"></script>
```

### Computing SRI Hashes

When adding or updating a CDN resource:

```bash
# IMPORTANT: use -L to follow redirects — otherwise you hash the 301 body
curl -sL https://unpkg.com/htmx.org@1.9.10 | openssl dgst -sha384 -binary | openssl base64 -A
```

---

## Container Security

The application runs as a non-root user inside Docker:

```dockerfile
# Dockerfile
RUN adduser --disabled-password --gecos '' appuser && chown -R appuser:appuser /app
```

```bash
# docker-entrypoint.sh
mkdir -p /app/uploads/meals
chown -R appuser:appuser /app/uploads
exec setpriv --reuid=appuser --regid=appuser --init-groups "$@"
```

The `chown` before `setpriv` ensures bind-mounted volumes have correct permissions before privileges are dropped.

---

## Secrets Management

- **Development**: Secrets live in a `.env` file (in `.gitignore`). See `deploy/.env.example` for the template.
- **Production**: Secrets are fetched from a secrets manager at deploy time and written with `chmod 600`.
- **Rules**: Never commit secrets. Never log them. Sensitive values are loaded from environment variables via `app/config.py`.

---

## AI/LLM Security

### Prompt Injection Mitigation

All AI interactions use structured defences:

1. **System/user role separation**: System prompts define behavior; user data is always in user messages, never interpolated into system prompts
2. **Pydantic schema validation**: Every AI response is parsed and validated against a strict Pydantic schema before use. Invalid responses trigger a retry, not a fallback to raw text
3. **No code execution**: AI responses are never evaluated as code
4. **No raw rendering**: AI output is rendered through Jinja2 autoescaping like all other content

Key files: `app/services/ai_schemas.py` (all response schemas), `app/services/ai_service.py`

### Response Schema Validation

Every AI method has a corresponding Pydantic model in `app/services/ai_schemas.py`:

| AI Method | Schema |
|-----------|--------|
| Meal image analysis | `MealAnalysisSchema` |
| Symptom clarification | `ClarifySymptomSchema` (discriminated union) |
| Episode detection | `EpisodeContinuationSchema` |
| Diagnosis correlations | `DiagnosisCorrelationsSchema` |
| Single ingredient diagnosis | `SingleIngredientDiagnosisSchema` |
| Root cause classification | `RootCauseSchema` |
| Ingredient research | `ResearchIngredientSchema` |

The `_call_with_schema_retry()` pattern in `ai_service.py` handles validation: parse JSON, validate against schema, retry on failure.

### Medical Ethics

The app includes several safeguards for responsible health information:

- **Qualified language**: AI prompts require hedging ("may", "could", "consider consulting")
- **Professional consultation**: Recommendations always suggest consulting a healthcare professional
- **Citation requirements**: Diagnosis results include citations from trusted medical sources
- **Confidence thresholds**: Results are only shown when statistical confidence is sufficient
- **Disclaimer**: A medical disclaimer is displayed on every page (`base.html:106-119`)

### Data Sent to AI

| Sent | Not Sent |
|------|----------|
| Meal photos | Passwords |
| Ingredient names/states | Session tokens |
| Symptom descriptions/types/severity | Email addresses |
| Historical meal/symptom data for diagnosis | User IDs |

### Guidance for New AI Features

When adding new AI-powered features:

1. **Define a Pydantic schema** in `ai_schemas.py` for the expected response
2. **Use `_call_with_schema_retry()`** to call the API with validation
3. **Keep user input in user messages** — never interpolate into system prompts
4. **Render through Jinja2** — never use `|safe` on AI output
5. **Add cost tracking** if the feature uses significant tokens

---

## Automated Security Scanning

### `/security-audit` Skill

The project includes a `/security-audit` Claude Code skill with three profiles:

| Profile | Time | Scope |
|---------|------|-------|
| `quick` | <2 min | Secrets detection (gitleaks), dependency audit (pip-audit) |
| `standard` | ~5 min | All tools: bandit, semgrep, hadolint, shellcheck, checkov, trivy |
| `deep` | 10-15 min | Standard + git history scan for leaked secrets |

Reports are saved to `~/.local/share/security-audit/<repo>/`.

### Running Security Tests

```bash
# Run all security tests
docker compose exec web pytest tests/security/ -m security -v

# Run specific test class
docker compose exec web pytest tests/security/test_auth_security.py::TestSessionSecurity -v
```

The security test suite covers:
- **`test_auth_security.py`**: Session security, access control, invite tokens, password hashing, open redirect prevention, admin privilege escalation
- **`test_htmx_security.py`**: XSS in partials, CSRF protection, htmx header handling, response headers, swap injection
- **`test_input_validation.py`**: SQL injection, XSS in all input fields, path traversal, command injection, JSON injection, integer overflow

---

## Security Checklist for PRs

Use this checklist when reviewing or submitting changes:

### Authentication & Authorization
- [ ] New routes use appropriate auth dependency (`get_current_user`, `require_auth_page`, `require_admin`)
- [ ] All data queries filter by `user_id` to enforce ownership
- [ ] Admin-only operations use `require_admin` or `require_admin_page`

### Input Handling
- [ ] No use of `|safe` on user-provided or AI-generated content in templates
- [ ] No raw SQL queries — all database access through SQLAlchemy ORM
- [ ] File uploads validated for content type, with server-generated filenames

### AI Features
- [ ] AI response validated through a Pydantic schema (`ai_schemas.py`)
- [ ] User input placed in user messages, not interpolated into system prompts
- [ ] AI output rendered through Jinja2 autoescaping

### Frontend
- [ ] New CDN resources include `integrity` and `crossorigin="anonymous"` attributes
- [ ] SRI hashes computed with `curl -sL` (follows redirects)
- [ ] Alpine.js data initialized via `<script>` tags with `|tojson`, not inline attributes

### Secrets & Configuration
- [ ] No secrets committed to the repository
- [ ] New config values added to `deploy/.env.example`
- [ ] Sensitive values loaded from environment, not hardcoded

### General
- [ ] Ran `/security-audit quick` and addressed findings
- [ ] Security tests pass: `docker compose exec web pytest tests/security/ -m security -v`
