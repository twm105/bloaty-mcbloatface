{% extends "base.html" %}

{% block title %}Log Symptoms - Bloaty McBloatface{% endblock %}

{% block content %}
<article>
    <header>
        <h1>{% if editing %}Update Symptom{% else %}Log Symptoms{% endif %}</h1>
        <p>Track how you're feeling to identify patterns with meals.</p>
    </header>

    <!-- Medical Disclaimer -->
    <section style="background-color: var(--card-background-color); border-left: 4px solid var(--primary); padding: 1rem; margin-bottom: 2rem;">
        <p style="margin: 0;"><strong>Medical Disclaimer:</strong> This tool is for personal tracking only and does not constitute medical advice. If you have concerning symptoms, please consult a healthcare professional.</p>
    </section>

    <!-- Initialize Alpine data from server -->
    <script>
        window.symptomInitData = {
            editing: {{ editing|default(false)|tojson }},
            symptomId: {{ symptom_id|default(none)|tojson }},
            selectedTags: {{ (symptom.tags if (editing and symptom and symptom.tags) else [])|tojson }},
            finalNotes: {{ (symptom.notes if (editing and symptom and symptom.notes) else none)|tojson }},
            startTime: {% if editing and symptom and symptom.start_time %}{{ symptom.start_time.strftime('%Y-%m-%dT%H:%M')|tojson }}{% else %}null{% endif %},
            endTime: {% if editing and symptom and symptom.end_time %}{{ symptom.end_time.strftime('%Y-%m-%dT%H:%M')|tojson }}{% else %}null{% endif %}
        };
    </script>

    <section
        x-data="{
            editing: window.symptomInitData.editing,
            symptomId: window.symptomInitData.symptomId,
            selectedTags: window.symptomInitData.selectedTags,
            currentTag: '',
            autocompleteSuggestions: [],
            commonTags: [],
            aiGeneratedText: null,
            finalNotes: window.symptomInitData.finalNotes,
            isGeneratingAi: false,
            ongoingDetection: null,
            showOngoingPopup: false,
            pendingTagIndex: null,
            isSubmitting: false,

            async init() {
                // Fetch common tags
                const response = await fetch('/symptoms/tags/common');
                const data = await response.json();
                this.commonTags = data.tags || [];

                // If editing, pre-populate times from existing symptom
                if (this.editing && this.selectedTags.length > 0) {
                    const startTime = window.symptomInitData.startTime;
                    const endTime = window.symptomInitData.endTime;

                    // Apply to all tags (expand first tag)
                    for (let i = 0; i < this.selectedTags.length; i++) {
                        this.selectedTags[i].expanded = (i === 0);
                        this.selectedTags[i].startTime = startTime;
                        this.selectedTags[i].endTime = endTime;
                        this.selectedTags[i].showStartTime = !!startTime;
                        this.selectedTags[i].showEndTime = !!endTime;
                    }
                }
            },

            async addTag(name, severity = 4.0) {  // Changed default from 5.0 to 4.0
                // Don't add duplicates
                if (this.selectedTags.some(t => t.name.toLowerCase() === name.toLowerCase())) {
                    return;
                }

                // Add new tag at START (unshift), expanded with per-symptom time properties
                const newTag = {
                    name: name,
                    severity: severity,
                    expanded: true,
                    startTime: null,
                    endTime: null,
                    showStartTime: false,
                    showEndTime: false,
                    episodeId: null
                };

                this.selectedTags.unshift(newTag);

                // Collapse all other tags
                for (let i = 1; i < this.selectedTags.length; i++) {
                    this.selectedTags[i].expanded = false;
                }

                this.currentTag = '';
                this.autocompleteSuggestions = [];

                // Check for ongoing symptom
                await this.checkForOngoing(0);  // Index 0 = just-added tag
            },

            removeTag(index) {
                this.selectedTags.splice(index, 1);
            },

            toggleExpand(index) {
                this.selectedTags[index].expanded = !this.selectedTags[index].expanded;
            },

            async searchTags() {
                if (this.currentTag.length < 2) {
                    this.autocompleteSuggestions = [];
                    return;
                }

                const response = await fetch('/symptoms/tags/autocomplete?q=' + encodeURIComponent(this.currentTag));
                const data = await response.json();
                this.autocompleteSuggestions = data.suggestions || [];
            },

            async checkForOngoing(tagIndex) {
                const tag = this.selectedTags[tagIndex];

                try {
                    const response = await fetch('/symptoms/detect-ongoing', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            symptom_name: tag.name,
                            symptom_severity: Math.round(tag.severity),
                            current_time: new Date().toISOString()
                        })
                    });

                    const data = await response.json();

                    if (data.potential_ongoing && data.confidence > 0.5) {
                        this.ongoingDetection = data;
                        this.pendingTagIndex = tagIndex;
                        this.showOngoingPopup = true;
                    }
                } catch (error) {
                    console.error('Ongoing detection failed:', error);
                }
            },

            confirmOngoing(choice) {
                const tagIndex = this.pendingTagIndex;
                const tag = this.selectedTags[tagIndex];
                const detection = this.ongoingDetection;

                if (choice === 'ignore') {
                    // User chose not to link
                    this.closeOngoingPopup();
                    return;
                }

                // Link to episode
                tag.episodeId = detection.potential_ongoing.id;

                // Inherit start time from original symptom
                tag.startTime = detection.potential_ongoing.start_time.slice(0, 16);  // Format for datetime-local
                tag.showStartTime = true;

                // Handle name choice
                if (choice === 'use_original') {
                    tag.name = detection.recommended_name;
                } else if (choice === 'use_new') {
                    // Keep current name
                }

                this.closeOngoingPopup();
            },

            closeOngoingPopup() {
                this.showOngoingPopup = false;
                this.ongoingDetection = null;
                this.pendingTagIndex = null;
            },

            applyStartTimeToAll(sourceIndex) {
                const sourceTime = this.selectedTags[sourceIndex].startTime;
                for (let tag of this.selectedTags) {
                    tag.startTime = sourceTime;
                    tag.showStartTime = true;
                }
            },

            applyEndTimeToAll(sourceIndex) {
                const sourceTime = this.selectedTags[sourceIndex].endTime;
                for (let tag of this.selectedTags) {
                    tag.endTime = sourceTime;
                    tag.showEndTime = true;
                }
            },

            async generateAiDescription() {
                if (this.selectedTags.length === 0) {
                    return;
                }

                this.finalNotes = '';  // Show textarea
                this.isGeneratingAi = true;

                try {
                    // Use first symptom's times if available
                    const firstTag = this.selectedTags[0];
                    const startTime = firstTag.showStartTime && firstTag.startTime ? new Date(firstTag.startTime).toISOString() : null;
                    const endTime = firstTag.showEndTime && firstTag.endTime ? new Date(firstTag.endTime).toISOString() : null;

                    const response = await fetch('/symptoms/tags/elaborate-stream', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            tags: this.selectedTags.map(t => ({name: t.name, severity: Math.round(t.severity)})),
                            start_time: startTime,
                            end_time: endTime
                        })
                    });

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();

                    while (true) {
                        const {done, value} = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        this.finalNotes += chunk;
                        this.aiGeneratedText = this.finalNotes;  // Track original
                        this.$nextTick(() => this.autoExpand(this.$refs.notesTextarea));
                    }
                } catch (error) {
                    console.error('AI elaboration failed:', error);
                    this.finalNotes = 'Failed to generate elaboration. Please try again.';
                } finally {
                    this.isGeneratingAi = false;
                }
            },

            autoExpand(textarea) {
                if (textarea) {
                    textarea.style.height = 'auto';
                    textarea.style.height = textarea.scrollHeight + 'px';
                }
            },

            getSeverityColor(severity) {
                if (severity < 4) return 'var(--form-element-valid-border-color)';  // 1-3.99
                if (severity < 7) return '#f5a623';                                  // 4-6.99
                return 'var(--form-element-invalid-border-color)';                   // 7-10
            },

            getSeverityLabel(severity) {
                if (severity < 4) return 'mild';      // 1-3.99
                if (severity < 7) return 'moderate';  // 4-6.99
                return 'severe';                      // 7-10
            },

            async submitForm() {
                if (this.selectedTags.length === 0) {
                    alert('Please add at least one symptom tag');
                    return;
                }

                this.isSubmitting = true;

                if (this.editing) {
                    // Update existing symptom
                    try {
                        // Get common start/end times (use first tag's times)
                        const firstTag = this.selectedTags[0];
                        const startTime = firstTag.showStartTime && firstTag.startTime ? new Date(firstTag.startTime).toISOString() : null;
                        const endTime = firstTag.showEndTime && firstTag.endTime ? new Date(firstTag.endTime).toISOString() : null;

                        const response = await fetch(`/symptoms/${this.symptomId}`, {
                            method: 'PUT',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({
                                tags: this.selectedTags.map(t => ({name: t.name, severity: Math.round(t.severity)})),
                                start_time: startTime,
                                end_time: endTime,
                                notes: this.finalNotes
                            })
                        });

                        if (response.ok) {
                            window.location.href = '/symptoms/history';
                        } else {
                            const error = await response.text();
                            alert('Failed to update symptom: ' + error);
                            this.isSubmitting = false;
                        }
                    } catch (error) {
                        console.error('Update failed:', error);
                        alert('Failed to update symptom: ' + error);
                        this.isSubmitting = false;
                    }
                } else {
                    // Create new symptom
                    const formData = new FormData();

                    // Build tags with per-symptom times
                    const tagsToSubmit = this.selectedTags.map(tag => ({
                        name: tag.name,
                        severity: Math.round(tag.severity),
                        start_time: tag.showStartTime && tag.startTime ? new Date(tag.startTime).toISOString() : null,
                        end_time: tag.showEndTime && tag.endTime ? new Date(tag.endTime).toISOString() : null,
                        episode_id: tag.episodeId || null
                    }));

                    formData.append('tags_json', JSON.stringify(tagsToSubmit));

                    // Send AI text fields
                    formData.append('ai_generated_text', this.aiGeneratedText || '');
                    formData.append('final_notes', this.finalNotes || '');

                    // Submit form
                    try {
                        const response = await fetch('/symptoms/create-tagged', {
                            method: 'POST',
                            body: formData
                        });

                        if (response.redirected) {
                            window.location.href = response.url;
                        } else if (response.ok) {
                            window.location.href = '/symptoms/history?success=true';
                        } else {
                            const error = await response.text();
                            alert('Failed to save symptom: ' + error);
                            this.isSubmitting = false;
                        }
                    } catch (error) {
                        console.error('Submit failed:', error);
                        alert('Failed to save symptom: ' + error);
                        this.isSubmitting = false;
                    }
                }
            }
        }"
    >
        <!-- Quick Add Tags -->
        <div style="margin-bottom: 1.5rem;">
            <label><strong>Quick Add:</strong></label>
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem;">
                <template x-for="tag in commonTags" :key="tag.name">
                    <button
                        type="button"
                        class="outline"
                        style="padding: 0.5rem 1rem; font-size: 0.9rem; text-transform: capitalize;"
                        @click="addTag(tag.name, tag.avg_severity)"
                        x-text="tag.name"
                    ></button>
                </template>
            </div>
        </div>

        <!-- Tag Input with Autocomplete -->
        <div style="margin-bottom: 1.5rem;">
            <label for="tag-input">
                Add Symptoms (Tags) *
                <small>Type to search or click quick add buttons above</small>
            </label>
            <div style="position: relative; margin-bottom: 1rem;">
                <input
                    type="text"
                    id="tag-input"
                    x-model="currentTag"
                    @input="searchTags()"
                    @keydown.enter.prevent="autocompleteSuggestions.length > 0 ? addTag(autocompleteSuggestions[0]) : addTag(currentTag)"
                    placeholder="Type symptom name (e.g., bloating, gas, nausea)..."
                    style="margin-bottom: 0;"
                >

                <!-- Autocomplete Dropdown -->
                <div
                    x-show="autocompleteSuggestions.length > 0"
                    style="position: absolute; top: calc(100% + 0.5rem); left: 0; right: 0; z-index: 9999; background: white; border: 2px solid var(--primary); border-radius: var(--border-radius); max-height: 200px; overflow-y: auto; box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3), 0 4px 8px rgba(0, 0, 0, 0.2);"
                    @click.away="autocompleteSuggestions = []"
                    x-cloak
                >
                    <template x-for="suggestion in autocompleteSuggestions" :key="suggestion">
                        <div
                            @click="addTag(suggestion)"
                            @mouseenter="$el.style.backgroundColor = 'var(--primary-focus)'"
                            @mouseleave="$el.style.backgroundColor = ''"
                            style="padding: 0.75rem; cursor: pointer; border-bottom: 1px solid var(--muted-border-color); text-transform: capitalize;"
                            x-text="suggestion"
                        ></div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Generate AI Description Button -->
        <div style="margin-bottom: 1.5rem;">
            <button
                type="button"
                @click="generateAiDescription()"
                :disabled="selectedTags.length === 0 || isGeneratingAi"
                :class="selectedTags.length === 0 ? 'secondary' : ''"
            >
                <span x-show="!isGeneratingAi">Generate Detailed Description</span>
                <span x-show="isGeneratingAi">Generating...</span>
            </button>
        </div>

        <!-- Selected Tags Display (Collapsible Cards) -->
        <div style="margin-bottom: 1.5rem;" x-show="selectedTags.length > 0" x-cloak>
            <label><strong>Selected Symptoms:</strong></label>
            <template x-for="(tag, index) in selectedTags" :key="tag.name + index">
                <div
                    @click="toggleExpand(index)"
                    :style="{
                        background: 'var(--card-background-color)',
                        border: tag.expanded ? '2px solid var(--primary)' : '2px solid var(--muted-border-color)',
                        borderRadius: 'var(--border-radius)',
                        padding: '1rem',
                        marginBottom: '1rem',
                        cursor: 'pointer'
                    }"
                >
                    <!-- Header (always visible) -->
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <strong x-text="tag.name" style="text-transform: capitalize;"></strong>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span x-text="getSeverityLabel(tag.severity) + ' (' + Math.round(tag.severity) + '/10)'"></span>
                            <span x-show="!tag.expanded">+</span>
                            <span x-show="tag.expanded">âˆ’</span>
                        </div>
                    </div>

                    <!-- Expanded view (conditional) -->
                    <div x-show="tag.expanded" x-cloak style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--muted-border-color);">
                        <!-- Severity slider -->
                        <label :for="'severity-' + index" style="font-size: 0.9rem; margin-bottom: 0.5rem; display: block;">
                            Severity: <span x-text="getSeverityLabel(tag.severity)"></span>
                        </label>
                        <input
                            type="range"
                            :id="'severity-' + index"
                            min="1"
                            max="10"
                            step="0.1"
                            x-model.number="tag.severity"
                            @click.stop
                            :style="{ accentColor: getSeverityColor(tag.severity) }"
                        >
                        <div style="display: flex; justify-content: space-between; font-size: 0.85rem; color: var(--muted-color); margin-top: 0.25rem;">
                            <span>mild (1)</span>
                            <span>moderate (5)</span>
                            <span>severe (10)</span>
                        </div>

                        <!-- Per-Symptom Time Controls -->
                        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--muted-border-color);">
                            <div style="margin-bottom: 0.5rem;">
                                <label>
                                    <input type="checkbox" x-model="tag.showStartTime" @click.stop>
                                    Set start time
                                </label>
                            </div>

                            <div x-show="tag.showStartTime" x-cloak style="margin-bottom: 1rem;">
                                <input
                                    type="datetime-local"
                                    x-model="tag.startTime"
                                    @click.stop
                                    style="width: 100%; margin-bottom: 0.5rem;"
                                >
                                <button
                                    type="button"
                                    class="outline"
                                    @click.stop="applyStartTimeToAll(index)"
                                    style="width: 100%; padding: 0.4rem; font-size: 0.85rem;"
                                >
                                    Apply to All Symptoms
                                </button>
                            </div>

                            <div style="margin-bottom: 0.5rem;">
                                <label>
                                    <input type="checkbox" x-model="tag.showEndTime" @click.stop>
                                    Set end time
                                </label>
                            </div>

                            <div x-show="tag.showEndTime" x-cloak>
                                <input
                                    type="datetime-local"
                                    x-model="tag.endTime"
                                    @click.stop
                                    style="width: 100%; margin-bottom: 0.5rem;"
                                >
                                <button
                                    type="button"
                                    class="outline"
                                    @click.stop="applyEndTimeToAll(index)"
                                    style="width: 100%; padding: 0.4rem; font-size: 0.85rem;"
                                >
                                    Apply to All Symptoms
                                </button>
                            </div>
                        </div>

                        <!-- Remove button (styled like meals UI) -->
                        <div style="text-align: right; margin-top: 1rem;">
                            <button
                                @click.stop="removeTag(index)"
                                class="secondary"
                                style="padding: 0.3rem 0.6rem; font-size: 0.9rem;"
                                title="Remove symptom"
                            >
                                <svg class="icon icon-xs" aria-hidden="true">
                                    <use href="/static/icons/lucide-sprite.svg#x"></use>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </template>
        </div>

        <!-- AI Notes Textarea (appears when streaming starts) -->
        <div x-show="finalNotes !== null" x-cloak style="margin-bottom: 1.5rem;">
            <label for="final-notes">
                Detailed Description
                <small>AI-generated (editable)</small>
            </label>
            <textarea
                id="final-notes"
                x-model="finalNotes"
                rows="4"
                style="resize: none; overflow: hidden;"
                x-ref="notesTextarea"
                @input="autoExpand($refs.notesTextarea)"
            ></textarea>
        </div>

        <!-- Ongoing Symptom Detection Popup (Centered Overlay) -->
        <div
            x-show="showOngoingPopup && ongoingDetection"
            x-cloak
            style="
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.6);
                z-index: 9999;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 1rem;
            "
        >
            <div style="
                background: white;
                padding: 2rem;
                border-radius: var(--border-radius);
                max-width: 500px;
                width: 100%;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            ">
                <h3 style="margin-top: 0;">Possible Ongoing Symptom Detected</h3>

                <p>
                    You previously logged
                    <strong x-text="ongoingDetection?.potential_ongoing?.name"></strong>
                    (severity: <span x-text="ongoingDetection?.potential_ongoing?.severity"></span>/10)
                    on <strong x-text="ongoingDetection?.potential_ongoing?.start_time ? new Date(ongoingDetection.potential_ongoing.start_time).toLocaleString() : ''"></strong>.
                </p>

                <div x-show="ongoingDetection && ongoingDetection.confidence > 0.7" style="font-size: 0.9rem; color: var(--muted-color); margin-bottom: 1rem; font-style: italic;">
                    <span x-text="ongoingDetection?.reasoning"></span>
                </div>

                <!-- Name Match Options (show if names differ) -->
                <div x-show="ongoingDetection && ongoingDetection.name_match === 'different'" style="margin-bottom: 1.5rem; padding: 1rem; background: #f0f0f0; border-radius: var(--border-radius);">
                    <p style="margin-top: 0;"><strong>Symptom names differ. Choose one:</strong></p>
                    <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                        <button type="button" class="outline" @click="confirmOngoing('use_original')" style="text-align: left;">
                            Use original name: <strong x-text="ongoingDetection?.recommended_name"></strong> (Recommended)
                        </button>
                        <button type="button" class="outline" @click="confirmOngoing('use_new')" style="text-align: left;">
                            Use new name: <strong x-text="selectedTags[pendingTagIndex]?.name"></strong>
                        </button>
                    </div>
                </div>

                <!-- Inheritance Info -->
                <div style="background: #e3f2fd; padding: 1rem; border-radius: var(--border-radius); margin-bottom: 1.5rem;">
                    <p style="margin: 0;"><strong>If you link this as ongoing:</strong></p>
                    <ul style="margin: 0.5rem 0 0 0; padding-left: 1.5rem;">
                        <li>Start time will be inherited from <span x-text="ongoingDetection?.potential_ongoing?.start_time ? new Date(ongoingDetection.potential_ongoing.start_time).toLocaleString() : ''"></span></li>
                        <li>This will be linked to the previous symptom episode</li>
                    </ul>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 1rem;">
                    <button type="button" @click="confirmOngoing('use_original')" x-show="ongoingDetection && ongoingDetection.name_match === 'exact'">
                        Yes, Link as Ongoing
                    </button>
                    <button type="button" class="secondary" @click="confirmOngoing('ignore')">
                        No, This is New
                    </button>
                </div>
            </div>
        </div>

        <!-- Submit -->
        <div style="margin-top: 2rem;">
            <button
                type="button"
                @click="submitForm()"
                :disabled="selectedTags.length === 0 || isSubmitting"
            >
                <span x-show="!isSubmitting">{% if editing %}Update{% else %}Approve Symptoms{% endif %}</span>
                <span x-show="isSubmitting">{% if editing %}Updating...{% else %}Approving...{% endif %}</span>
            </button>
            <a href="/symptoms/history" role="button" class="secondary">Cancel</a>
        </div>
    </section>
</article>
{% endblock %}
