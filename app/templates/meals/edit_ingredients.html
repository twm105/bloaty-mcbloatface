{% extends "base.html" %}

{% block title %}Add Ingredients - Bloaty McBloatface{% endblock %}

{% block content %}
<article x-data="{
    showForm: false,
    ingredientName: '',
    state: 'raw',
    quantity: ''
}">
    <!-- Image at top -->
    {% if meal.image_path %}
    <section style="width: 100%; display: block;">
        <img src="/{{ meal.image_path }}" alt="Meal photo" class="meal-image-preview">
    </section>
    {% endif %}

    <!-- AI container: analyzing status OR complete content (replaced by htmx) -->
    <div id="ai-container">
    {% if meal.image_path and not meal.meal_ingredients %}
        <!-- Analyzing status -->
        <div
            hx-post="/meals/{{ meal.id }}/analyze-image"
            hx-trigger="load"
            hx-target="#ai-container"
            hx-swap="outerHTML"
            style="
                background: #e3f2fd;
                border-left: 4px solid #2196F3;
                color: #1565C0;
                padding: 0.75rem 1rem;
                border-radius: 8px;
                margin-bottom: 1.5rem;
                font-size: 14px;
                display: flex;
                align-items: center;
                gap: 0.75rem;
            "
        >
            <div class="spinner-small"></div>
            <span>Analyzing meal image with AI...</span>
        </div>
    {% else %}
        <!-- Content section (already analyzed or no image) -->
        <div id="analysis-and-ingredients">
        <header style="margin-bottom: 1.5rem;">
            <h1
                id="meal-name-header"
                onclick="makeEditable(this, {{ meal.id }}, null, 'meal_name')"
                style="cursor: text; padding: 0.25rem; border-radius: 8px; margin-bottom: 0.5rem;"
                title="Click to edit meal name"
            >
                {{ meal.name or 'Untitled Meal' }}
            </h1>
            <p style="font-size: 14px; color: #666; margin: 0;">Click any field to edit</p>
        </header>

        <!-- Ingredients List -->
        <section style="margin-bottom: 1.5rem;">
            <h3>Ingredients</h3>

            <div id="ingredients-list">
                {% if meal.meal_ingredients %}
                    {% for meal_ingredient in meal.meal_ingredients %}
                        {% include 'meals/partials/ingredient_item.html' %}
                    {% endfor %}
                {% else %}
                    <p id="no-ingredients-message" style="color: #999; font-style: italic;">No ingredients added yet.</p>
                {% endif %}
            </div>
        </section>

        <!-- Meal Analysis Feedback (shown if AI analysis was performed) -->
        {% if meal.ai_suggested_ingredients %}
        <section style="margin-top: var(--space-6);">
            {% set entity_type = 'meal_analysis' %}
            {% set entity_id = meal.id %}
            {# existing_rating and existing_feedback passed from route #}
            {% include 'components/_feedback_rating.html' %}
        </section>
        {% endif %}
        </div>
    {% endif %}
    </div>

    <!-- Add Ingredient Button -->
    <section style="margin-bottom: var(--space-6);">
        <button
            @click="showForm = !showForm"
            class="btn-secondary btn-sm"
            type="button"
        >
            <svg width="12" height="12" viewBox="0 0 24 24" class="icon icon-xxs" aria-hidden="true" style="stroke-width: 1.5;">
                <use href="/static/icons/lucide-sprite.svg#plus"></use>
            </svg>
            Add Ingredient
        </button>
    </section>

    <!-- Add Ingredient Form -->
    <section x-show="showForm" x-cloak style="margin-bottom: var(--space-6);">
        <form
            hx-post="/meals/{{ meal.id }}/ingredients/add"
            hx-target="#ingredients-list"
            hx-swap="beforeend"
            @htmx:after-request="ingredientName = ''; quantity = ''; showForm = false; document.getElementById('no-ingredients-message')?.remove()"
        >
            <!-- Name and State Row -->
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: var(--space-4); margin-bottom: var(--space-4);">
                <div>
                    <label for="ingredient_name" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-medium); color: var(--color-text-primary);">
                        Ingredient Name *
                    </label>
                    <input
                        type="text"
                        id="ingredient_name"
                        name="ingredient_name"
                        x-model="ingredientName"
                        placeholder="e.g., chicken breast, olive oil"
                        required
                        autofocus
                        style="width: 100%;"
                    >
                </div>
                <div>
                    <label for="state" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-medium); color: var(--color-text-primary);">
                        State *
                    </label>
                    <select id="state" name="state" x-model="state" required style="width: 100%;">
                        {% for state_value in ingredient_states %}
                        <option value="{{ state_value }}">{{ state_value.capitalize() }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>

            <!-- Quantity Row with spacing -->
            <div style="margin-bottom: var(--space-5);">
                <label for="quantity" style="display: block; margin-bottom: var(--space-2); font-weight: var(--font-medium); color: var(--color-text-primary);">
                    Quantity (Optional)
                </label>
                <input
                    type="text"
                    id="quantity"
                    name="quantity"
                    x-model="quantity"
                    placeholder="e.g., 2 cups, 100g, a handful"
                    style="width: 100%;"
                >
                <small style="display: block; margin-top: var(--space-2); color: var(--color-text-secondary);">
                    Examples: "2 cups", "100g", "a handful"
                </small>
            </div>

            <!-- Buttons -->
            <div style="display: flex; gap: var(--space-3);">
                <button type="submit" class="btn-primary">
                    Add Ingredient
                </button>
                <button
                    type="button"
                    @click="showForm = false; $el.closest('form').reset();"
                    class="btn-secondary"
                >
                    Cancel
                </button>
            </div>
        </form>
    </section>

    <!-- Meal Metadata (editable inline) -->
    <section style="
        margin-bottom: var(--space-6);
        padding: var(--space-5);
        background: var(--color-bg-secondary);
        border-radius: var(--radius-md);
        border: 1px solid rgba(255, 255, 255, 0.05);
    ">
        <h4 style="margin-top: 0; margin-bottom: var(--space-4); color: var(--color-text-primary);">
            Meal Details
        </h4>

        <div style="display: grid; gap: var(--space-4);">
            <!-- When -->
            <div>
                <small style="
                    display: block;
                    color: var(--color-text-secondary);
                    margin-bottom: var(--space-2);
                    font-weight: var(--font-medium);
                    text-transform: uppercase;
                    font-size: var(--text-xs);
                    letter-spacing: 0.5px;
                ">
                    When
                </small>
                <span
                    id="timestamp-{{ meal.id }}"
                    data-timestamp="{{ meal.timestamp.strftime('%Y-%m-%dT%H:%M') }}"
                    onclick="makeEditableTimestamp(this, {{ meal.id }})"
                    style="
                        cursor: pointer;
                        padding: var(--space-2) var(--space-3);
                        border-radius: var(--radius-sm);
                        background: rgba(255, 255, 255, 0.03);
                        border: 1px solid rgba(255, 255, 255, 0.08);
                        display: inline-block;
                        transition: all var(--transition-base);
                        color: var(--color-text-primary);
                        font-size: var(--text-sm);
                    "
                    onmouseover="this.style.borderColor='rgba(255, 255, 255, 0.15)'"
                    onmouseout="this.style.borderColor='rgba(255, 255, 255, 0.08)'"
                    title="Click to edit date/time"
                >
                    {{ meal.timestamp.strftime('%B %d, %Y at %I:%M %p') }}
                </span>
            </div>

            <!-- Where -->
            <div>
                <small style="
                    display: block;
                    color: var(--color-text-secondary);
                    margin-bottom: var(--space-2);
                    font-weight: var(--font-medium);
                    text-transform: uppercase;
                    font-size: var(--text-xs);
                    letter-spacing: 0.5px;
                ">
                    Where
                </small>
                <span
                    id="country-{{ meal.id }}"
                    onclick="makeEditableMetadata(this, {{ meal.id }}, 'country')"
                    style="
                        cursor: pointer;
                        padding: var(--space-2) var(--space-3);
                        border-radius: var(--radius-sm);
                        background: rgba(255, 255, 255, 0.03);
                        border: 1px solid rgba(255, 255, 255, 0.08);
                        display: inline-block;
                        transition: all var(--transition-base);
                        color: {% if meal.country %}var(--color-text-primary){% else %}var(--color-text-secondary){% endif %};
                        font-style: {% if not meal.country %}italic{% else %}normal{% endif %};
                        font-size: var(--text-sm);
                    "
                    onmouseover="this.style.borderColor='rgba(255, 255, 255, 0.15)'"
                    onmouseout="this.style.borderColor='rgba(255, 255, 255, 0.08)'"
                    title="Click to edit location"
                >
                    {{ meal.country or 'Add location' }}
                </span>
            </div>

            <!-- Notes -->
            <div>
                <small style="
                    display: block;
                    color: var(--color-text-secondary);
                    margin-bottom: var(--space-2);
                    font-weight: var(--font-medium);
                    text-transform: uppercase;
                    font-size: var(--text-xs);
                    letter-spacing: 0.5px;
                ">
                    Notes
                </small>
                <span
                    id="notes-{{ meal.id }}"
                    onclick="makeEditableMetadata(this, {{ meal.id }}, 'notes')"
                    style="
                        cursor: pointer;
                        padding: var(--space-2) var(--space-3);
                        border-radius: var(--radius-sm);
                        background: rgba(255, 255, 255, 0.03);
                        border: 1px solid rgba(255, 255, 255, 0.08);
                        display: block;
                        transition: all var(--transition-base);
                        color: {% if meal.user_notes %}var(--color-text-primary){% else %}var(--color-text-secondary){% endif %};
                        font-style: {% if not meal.user_notes %}italic{% else %}normal{% endif %};
                        font-size: var(--text-sm);
                        min-height: 60px;
                    "
                    onmouseover="this.style.borderColor='rgba(255, 255, 255, 0.15)'"
                    onmouseout="this.style.borderColor='rgba(255, 255, 255, 0.08)'"
                    title="Click to add notes"
                >
                    {{ meal.user_notes or 'Add notes' }}
                </span>
            </div>
        </div>
    </section>

    <!-- Save Meal Button -->
    <section style="margin-top: 2rem;">
        <form action="/meals/{{ meal.id }}/complete" method="post">
            <button type="submit" class="contrast pill-button" style="width: 100%;">
                Save Meal
            </button>
        </form>

        <details style="margin-top: 1rem;">
            <summary>What do the states mean?</summary>
            <ul>
                <li><strong>Raw:</strong> Uncooked ingredients (e.g., raw vegetables, uncooked meat)</li>
                <li><strong>Cooked:</strong> Cooked or heated ingredients (e.g., grilled chicken, steamed vegetables)</li>
                <li><strong>Processed:</strong> Commercially processed foods (e.g., canned goods, packaged snacks)</li>
            </ul>
            <p><small>Tracking ingredient state helps identify if preparation method affects symptoms.</small></p>
        </details>
    </section>
</article>
{% endblock %}

{% block scripts %}
<script>
// Update ingredient state via dropdown
function updateIngredientState(ingredientId, newState) {
    fetch(`/meals/ingredients/${ingredientId}/state`, {
        method: 'PATCH',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ state: newState })
    })
    .then(response => {
        if (!response.ok) {
            alert('Failed to update state');
            location.reload(); // Revert on error
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Failed to update state');
        location.reload();
    });
}

// Helper function for inline editing metadata (country, notes)
function makeEditableMetadata(element, mealId, field) {
    // If already editing, don't select all - let user click to position cursor
    const alreadyEditing = element.contentEditable === 'true';

    element.contentEditable = true;
    element.focus();

    const originalValue = element.textContent;
    const isPlaceholder = originalValue === 'Add location' || originalValue === 'Add notes';

    if (isPlaceholder) {
        element.textContent = '';
    } else if (!alreadyEditing) {
        // Only select all on first click (not a placeholder)
        const range = document.createRange();
        range.selectNodeContents(element);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
    }
    // If already editing, clicking again will position cursor naturally

    function save() {
        const newValue = element.textContent.trim();

        if (!newValue || newValue === originalValue) {
            element.textContent = originalValue;
            element.contentEditable = false;
            return;
        }

        // Determine endpoint and payload
        let url = `/meals/${mealId}`;
        let body;

        if (field === 'country') {
            body = new URLSearchParams({ country: newValue });
        } else if (field === 'notes') {
            body = new URLSearchParams({ user_notes: newValue });
        }

        // Save to server
        fetch(url, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: body
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'updated') {
                element.contentEditable = false;
                element.style.color = '';
                element.style.fontStyle = '';
            } else {
                element.textContent = originalValue;
                element.contentEditable = false;
            }
        })
        .catch(error => {
            console.error('Save failed:', error);
            element.textContent = originalValue;
            element.contentEditable = false;
        });
    }

    element.addEventListener('blur', save, { once: true });
    element.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            element.blur();
        } else if (e.key === 'Escape') {
            element.textContent = originalValue;
            element.blur();
        }
    }, { once: true });
}

// Helper function for inline editing timestamp with datetime-local input
function makeEditableTimestamp(element, mealId) {
    const currentTimestamp = element.dataset.timestamp;
    const originalDisplay = element.textContent;
    const originalStyles = element.style.cssText;

    // Create datetime-local input
    const input = document.createElement('input');
    input.type = 'datetime-local';
    input.value = currentTimestamp;
    input.style.cssText = `
        padding: var(--space-2) var(--space-3);
        border-radius: var(--radius-sm);
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid var(--color-accent);
        color: var(--color-text-primary);
        font-size: var(--text-sm);
        font-family: inherit;
        outline: none;
    `;

    // Replace span with input
    element.replaceWith(input);
    input.focus();

    function restoreDisplay(displayText, timestamp) {
        const span = document.createElement('span');
        span.id = `timestamp-${mealId}`;
        span.dataset.timestamp = timestamp;
        span.onclick = () => makeEditableTimestamp(span, mealId);
        span.style.cssText = originalStyles;
        span.onmouseover = function() { this.style.borderColor = 'rgba(255, 255, 255, 0.15)'; };
        span.onmouseout = function() { this.style.borderColor = 'rgba(255, 255, 255, 0.08)'; };
        span.title = 'Click to edit date/time';
        span.textContent = displayText;
        input.replaceWith(span);
    }

    function saveTimestamp() {
        const newValue = input.value;

        if (!newValue || newValue === currentTimestamp) {
            restoreDisplay(originalDisplay, currentTimestamp);
            return;
        }

        // Save to server
        fetch(`/meals/${mealId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({ timestamp: newValue })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'updated') {
                // Format the new date for display
                const date = new Date(newValue);
                const options = {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                };
                const formattedDate = date.toLocaleDateString('en-US', options).replace(',', ' at');
                restoreDisplay(formattedDate, newValue);
            } else {
                restoreDisplay(originalDisplay, currentTimestamp);
            }
        })
        .catch(error => {
            console.error('Save failed:', error);
            restoreDisplay(originalDisplay, currentTimestamp);
        });
    }

    input.addEventListener('blur', saveTimestamp);
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
        } else if (e.key === 'Escape') {
            restoreDisplay(originalDisplay, currentTimestamp);
        }
    });
}

// Helper function for inline editing
function makeEditable(element, mealId, ingredientId, field) {
    // If already editing, don't select all - let user click to position cursor
    const alreadyEditing = element.contentEditable === 'true';

    element.contentEditable = true;
    element.focus();

    const originalValue = element.textContent;

    // Only select all on first click
    if (!alreadyEditing) {
        const range = document.createRange();
        range.selectNodeContents(element);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
    }
    // If already editing, clicking again will position cursor naturally

    function save() {
        const newValue = element.textContent.trim();

        if (newValue === originalValue || !newValue) {
            element.textContent = originalValue;
            element.contentEditable = false;
            return;
        }

        // Determine endpoint and payload
        let url, body;
        if (field === 'meal_name') {
            url = `/meals/${mealId}/name`;
            body = new URLSearchParams({ name: newValue });
        } else if (field === 'ingredient_name') {
            url = `/meals/${mealId}/ingredients/${ingredientId}`;
            body = new URLSearchParams({ ingredient_name: newValue });
        } else if (field === 'quantity') {
            url = `/meals/${mealId}/ingredients/${ingredientId}`;
            body = new URLSearchParams({ quantity: newValue });
        }

        // Save to server
        fetch(url, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: body
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'updated') {
                element.contentEditable = false;
                // Update with server response if needed
                if (data.ingredient_name && field === 'ingredient_name') {
                    element.textContent = data.ingredient_name;
                } else if (data.quantity !== undefined && field === 'quantity') {
                    element.textContent = data.quantity || 'Add quantity';
                } else if (data.name && field === 'meal_name') {
                    element.textContent = data.name;
                }
            } else {
                element.textContent = originalValue;
                element.contentEditable = false;
            }
        })
        .catch(error => {
            console.error('Save failed:', error);
            element.textContent = originalValue;
            element.contentEditable = false;
            alert('Failed to save. Please try again.');
        });
    }

    element.addEventListener('blur', save, { once: true });
    element.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            element.blur();
        } else if (e.key === 'Escape') {
            element.textContent = originalValue;
            element.blur();
        }
    }, { once: true });
}

// Reusable feedback rating component (unified API)
function feedbackRating(config) {
    return {
        featureType: config.featureType || 'meal_analysis',
        featureId: config.featureId,
        endpoint: config.endpoint || '/feedback',
        rating: config.existingRating || 0,
        feedback: config.existingFeedback || '',
        savedFeedback: config.existingFeedback || '',
        hasRated: config.existingRating > 0,
        submitting: false,
        commentSubmitting: false,

        get commentDirty() {
            return this.feedback.trim() !== this.savedFeedback.trim();
        },

        get commentButtonText() {
            if (this.savedFeedback) {
                return this.commentDirty ? 'Update Comment' : 'Comment Saved';
            }
            return 'Add Comment';
        },

        async submitRating(stars) {
            this.rating = stars;
            this.submitting = true;

            try {
                const formData = new FormData();
                formData.append('feature_type', this.featureType);
                formData.append('feature_id', this.featureId);
                formData.append('rating', stars);
                if (this.savedFeedback) {
                    formData.append('feedback_text', this.savedFeedback);
                }

                await fetch(this.endpoint, {
                    method: 'POST',
                    body: formData
                });

                this.hasRated = true;
            } catch (err) {
                console.error('Failed to submit rating:', err);
            } finally {
                this.submitting = false;
            }
        },

        async submitComment() {
            if (!this.feedback.trim() || !this.commentDirty) return;

            this.commentSubmitting = true;

            try {
                const formData = new FormData();
                formData.append('feature_type', this.featureType);
                formData.append('feature_id', this.featureId);
                formData.append('rating', this.rating);
                formData.append('feedback_text', this.feedback);

                await fetch(this.endpoint, {
                    method: 'POST',
                    body: formData
                });

                this.savedFeedback = this.feedback;
            } catch (err) {
                console.error('Failed to submit comment:', err);
            } finally {
                this.commentSubmitting = false;
            }
        }
    };
}
</script>
{% endblock %}
